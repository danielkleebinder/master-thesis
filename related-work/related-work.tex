\label{sec:related-work}

\newacronym{sla}{SLA}{Service-Level-Agreement}
\newacronym{soa}{SOA}{Service-oriented Architecture}
\newacronym{baas}{BaaS}{Blockchain-as-a-Service}
\newacronym{bpm}{BPM}{Business Process Management}
\newacronym{bpmn}{BPMN}{Business Process Model and Notation}
\newacronym{bct}{BCT}{Blockchain Technology}
\newacronym{bpms}{BPMS}{Business Process Management System}

This chapter will briefly discuss the methodology used to conduct the literature review and outlines relevant related work in the field of business process management that utilizes \gls{bct} to establish properties such as trust and tamper-proofness. At the end of the chapter, the described concepts will be compared with each other and with the proposed approach of this thesis.

\section{Literature Review Methodology}
\label{sec:related-work:methodology}
The following literature review has been performed using the narrative review methodology with its focus on the state of the art~\cite{literature_review_stratton}. Since \glspl{bct}, and especially the utilization of \glspl{bct} in the area of \gls{bpm}, are rather new research topics, only literature of the last 10 years (i.e.,\ 2012 -- 2022) is considered relevant. The literature review is used to answer RQ1. Table~\ref{tab:literature_review_keywords} shows a list of primary, secondary and tertiary search terms that were used during the narrative review in the databases of \textit{Elsevier}, \textit{Springer}, \textit{IEEE} and \textit{Researchgate}.

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|}
    \hline
    \textbf{A} & \textbf{B} & \textbf{C} \\
    \hline
    \makecell{Blockchain} &
    \makecell{Collaborative\\Choreography\\Inter-organizational} &
    \makecell{Business Process\\Business Process Management} \\
    \hline
\end{tabular}
\caption{Search terms used during the narrative review}
\label{tab:literature_review_keywords}
\end{table}

The formal definition on how these search terms were combined is shown in equation~\ref{eq:literature_review_keyword_combination}.

\begin{equation}
E = [(\bigvee_{1 \leq i \leq 1} A_{i}) \wedge (\bigvee_{1 \leq i \leq 3} B_{i})] \wedge (\bigvee_{1 \leq i \leq 2} C_{i})
\label{eq:literature_review_keyword_combination}
\end{equation}

Narrative literature reviews do not claim (semi-)completeness on the coverage of a certain topic but give more of a rather unstructured overview of what already exists~\cite{literature_review_rhoades}. Systematic literature reviews such as~\cite{slr_collaborative_bpm_using_blockchain} found using equation~\ref{eq:literature_review_keyword_combination} were used as starting point. Furthermore, the snowballing approach was applied to extract primary sources. % chktex 36


\subsection{Untrusted Business Process Monitoring and Execution Using Blockchain~\cite{untrusted_bp_execution_using_blockchain}}

The ground-laying work for business process execution utilizing the blockchain published by Weber et al.\ (regularly cited in subsequent work such as~\cite{runtime_verification_for_bp_utilizing_bitcoin,bo_collaboration_between_healthcare_providers_covid_19,caterpillar_blockchain_based_bpm_system,modeling_blockchain_based_choreographies,blockchain_based_information_sharing_in_io_workflows}), aims to find agreements between counterparties on a shared state without the use of a trusted third party. In their exemplary use case, the authors outline a situation where a manufacturer orders supplies via a middleman, and the entire supply chain gets delayed because of production issues on the suppliers' side. Due to the delay, the manufacturer now refuses to accept the supplies from the carrier, which makes the carrier eligible for compensational payments from the supplier or the middleman. To tackle common~\cite{impact_of_trust_on_supply_chains}, trust-related, supply chain issues like these, Weber et al.\ suggest the integration of business processes into \gls{bct}. Their approach is split into design and run-time decisions. During design-time, a formal model of the business process has to be outlined using a description language similar to \gls{bpmn} or more blockchain-specific alternatives such as the one described by Ladleif et al.\ in~\cite{modeling_blockchain_based_choreographies}. This model is then translated into a factory smart contract containing all relevant business process information. The component-based design of this concept allows implementers to use custom translators, such as the one described by Nakamura et al.~\cite{inter_organizational_bps_managed_by_blockchain}, as well. During run-time, the factory smart contract is used to instantiate and deploy instance contracts that additionally contain information about the roles of the participants (which might not be obvious during design-time). Participants only communicate with each other (and send data) through the blockchain and the deployed instance contracts. These contracts are available in two different forms: (1) a \textit{choreography monitor}, which will check conformance with the business process, and (2) an \textit{active monitor} which is an extension of the \textit{choreography monitor} and can perform additional data transformations or calculations on-chain. Which one to choose depends on the use case and if the data is encrypted. Instance contracts hold and advance the status of the business process and the choreography rules and can trigger external APIs using \textit{triggers}. Triggers are programs that run on full-nodes and listen to smart contract events. Participants will then further process data off-chain that was sent over the blockchain. Due to the payload limitations of transactions on blockchains like Ethereum~\cite{ethereum_yellow_paper}, only smaller payloads might be transferred directly. For larger payloads, just the hash of the data is attached to the transaction, and the data itself is made available using off-chain storage solutions such as Amazon S3\footnote{\url{https://aws.amazon.com/de/s3/} (accessed on 2022-11-29)} or Google Cloud Storage\footnote{\url{https://cloud.google.com/storage} (accessed on 2022-11-29)}.

However, the on-chain logic and complexity of business processes are limited due to the 24 KB size limit of smart contracts on Ethereum~\cite{ethereum_yellow_paper}. This issue can be circumnavigated by applying the \textit{diamond pattern}\footnote{\url{https://eips.ethereum.org/EIPS/eip-2535} (accessed on 2022-11-29)}, but will inevitably add overall complexity and cost due to the increased amount of smart contracts that have to be deployed. For fairness, the authors suggest that participants may want to split gas money (including smart contract deployments) differently rather than relying on the implicit split of the business process itself. For their prototype, Weber et al.\ rely on the public Ethereum blockchain. In their benchmarks, the authors ran around 7932 transactions in 32 instances where each business process executed from start to end produced costs of around $0.0347$ Ether, which, in 2016, translated to around $0.40$ USD but are $109.49$ USD at the time of writing this work in 2022. With the fluctuation of prices of cryptocurrencies~\cite{predicting_cryptocurrency_price_bubbles,monitoring_financial_stability_cryptocurrencies}, conflicts between counterparties might be an aspect to consider when running long-term business processes. Regarding privacy, the authors suggest the usage of asymmetric encryption of data transferred over the blockchain or to rely entirely on permissioned blockchains. Private permissioned blockchains, however, are typically less accepted by industry partners~\cite{public_chains_make_private_chains_obsolete}, which will lead to centralization and thus nullifies the advantages of blockchains in the first place.

The authors utilized and extended upon their approach to implement a prototypical \gls{bpms} as proof-of-concept called Caterpillar\footnote{\url{https://github.com/orlenyslp/Caterpillar} (accessed on 2022-11-29)}. Caterpillar allows the factory and instance smart contract creation from \gls{bpmn} models and deploys them on the blockchain. When generating smart contracts from \gls{bpmn}, the system creates an intermediary representation of the business process using Petri nets to allow further optimization of the created smart contracts~\cite{optimized_execution_of_bp_using_petri_nets_on_blockchain}. Furthermore, their system exposes a REST API to make working with business processes more convenient~\cite{caterpillar_blockchain_based_bpm_system,caterpillar_bp_execution_engine_on_eth}.


\subsection{An Architecture for Multi-chain Business Process Choreographies~\cite{architecture_for_multi_chain_bp_ladleif}}

Leveraging on the aforementioned concept of Weber et al.~\cite{untrusted_bp_execution_using_blockchain}, Ladleif et al.\ presented a software architecture that aims to enable the usage of different blockchain technologies (e.g.,\ Ethereum, Hyperledger, Tezos, and others) in a single business process instance. To achieve this goal, the authors only used the blockchain and its smart contracts to store the state and all allowed state transitions of a business process instance. The event and transaction logs provided by most blockchain implementations with smart contract capabilities are used to verify if the \glspl{sla} are fulfilled. To enable multi-chain capabilities, the \textit{adapter} software design pattern is utilized where each blockchain, that participants want to integrate, has to implement its own adapter that is able to generate smart contract code, deploy it autonomously and interact with it later on. In most choreographies, not all participants are required to be part of each individual sub-process. Therefore, the system itself determines which parts are relevant for each participant and only connects to the respective smart contracts and blockchains. 

The presented concept gives involved participants more freedom over which blockchain to choose and therefore allows for a more fine-grained adjustment of levels of confidentiality or risk tolerance. Being able to combine different blockchains in a single choreography might be a desirable property depending on the use case and the business needs. Nonetheless, cross-chain communication is still an open problem that might increase the complexity of such a system unnecessarily. Thus, one must consider whether such a system is appropriate for the business process in use.


\subsection{Runtime verification for business processes utilizing the Bitcoin blockchain~\cite{runtime_verification_for_bp_utilizing_bitcoin,prybila_master_thesis}}

The conceptual model and the prototype presented by Prybila et al.\ aim to utilize and integrate business processes directly into the Bitcoin blockchain. Therefore, establish trust between counterparties by enabling time-independent verifiability of decentralized choreographies. Their rather flexible approach to this problem allows the process owner to select participants during runtime. This is a useful trait to have considering long-running processes where participants may drop out or get replaced due to changing requirements. At the start of a new business process, the process owner has to select a free Bitcoin transaction output\footnote{While Bitcoin transaction inputs determine how much value is transferred from one or more addresses, Bitcoin transaction outputs determine to which addresses the value is sent. Typically the input value is larger than the output value. This difference is the block miners reward.} which is used as control token. This control token will be handed over (by using a Bitcoin transaction) to the party that has to perform the next task (i.e.,\ the token holder is fully responsible for the continuation of the business process). In order to enable parallelization of tasks, this concept not only allows process-start, -end, and -handover transactions but also -split and -join transactions. A process-split transaction is performed by the current token holder and contains $1$ to $N$ new process tokens in the form of Bitcoin transaction outputs. The new token owners perform their tasks before joining the process back together. It is assumed that a single process-split corresponds to exactly one process-join later on. The authors defined a process-end transaction as a transaction with only a single input which means that a process-join must be performed before a process can complete (if the process was split earlier on). To define the different enriched transaction types, the \textit{data output} and the \textit{Pay-to-Script-Hash} standard Bitcoin transactions are used. The latter of both can carry additional data if necessary. The data will be transferred off-chain, and the transaction itself will only include a hash of the data due to privacy concerns and the fact that Bitcoin is a public permissionless blockchain. Due to the process timestamps and the publicly available data on the blockchain, process owners can monitor the progress of the entire business process and even of single tasks if made available by the current control token owner. The immutability of data on-chain allows the process owner to monitor the progress and verify if predefined \glspl{sla} are fulfilled accordingly.

Due to a median transaction confirmation time of around 7.74 minutes of Bitcoin measured by the authors, only long-running business processes and tasks are viable~\cite{runtime_verification_for_bp_utilizing_bitcoin}. However, their concept also includes a \textit{greedy mode} that allows handover of the control token even if a transaction was not yet confirmed and included in a block. This is because Bitcoin miners accept transactions with references to other, still pending, transactions~\cite{nakamoto2009}. \textit{Greedy} transactions, however, pose the threat of being entirely dropped if something goes wrong or malicious participants propose alternative handover transactions. Thus imposing possible consistency issues upon the entire business process and making \textit{greedy mode} practically unviable if trust is of utmost importance. The use of the Bitcoin network itself is also questionable because newer, second-generation blockchains, such as Ethereum, provide Turing-complete scripting languages that can depict requirements directly on-chain and can be used to share digital assets between organizations more easily~\cite{bo_collaboration_between_healthcare_providers_covid_19,buterin2020,ethereum_yellow_paper}. Also the way data is transferred between participants might pose certain security issues. Once written to the blockchain, the hash cannot be changed and will be available to the public as long as the blockchain itself is available. Even though not a main concern, malicious participants could still abuse this fact at a later point in time and present different data by using collision attacks posing certain security and trust issues. Data once hashed using MD5 or SHA-1 might no longer be reliably verifiable~\cite{new_collision_attack_on_md5,first_collision_for_full_sha_1}.


\subsection{Blockchain-oriented Inter-organizational Collaboration between Healthcare Providers to Handle the COVID-19 Process~\cite{bo_collaboration_between_healthcare_providers_covid_19}}

Ilyass El Kassmi and Zahi Jarir presented a conceptual model with a proof-of-concept implementation to handle trust issues when sharing sensitive data in the healthcare sector on a national scale. The authors oriented themselves on a large-scale pandemic use case regarding COVID-19. This concept is especially interesting because it aims to deal with large amounts of data, a changing business process, and privacy concerns. However, it does not focus on the security aspects. To handle ever-changing business processes, the authors use finite state automata modeling and map the model to a \gls{soa} to abstract functional and non-functional requirements onto the software architecture. The blockchain, in this case, Hyperledger, is dynamically plugged into the system as a third-party service that introduces a new level of indirection. This \gls{baas} approach allows for other blockchains to be used as well and enables a higher level of decentralization since private permissioned blockchains are typically considered to be more centralized since network maintainability is typically ensured by one authority only. The authors introduced the blockchain to depict non-functional requirements, like enabling trust for inter-organizational collaboration only. In this approach, blockchain interactions are seen as a way to fulfill those predefined behavioral non-functional requirements. After processing a workflow step locally, the \gls{soa} will forward certain sub-tasks to the blockchain and corresponding smart contracts. Other participants will (automatically) react to those changes in the smart contract and dispatch new events themselves if necessary. In the case of their COVID-19 use case, this might be a PCR test result published by the regional epidemiological center that, depending if the test was positive or negative, is being further processed by the governmental healthcare provider.

Although this novel approach fits this specific use case, it does not generalize well. The authors conclude, that it still heavily depends on the chosen blockchain platform and its limitations in terms of security, scalability, performance, and other key aspects. This might cause issues, especially with short-running business processes. The usage of permissioned blockchains also comes with certain restrictions. Due to the small number of participants compared to public permissionless blockchains, misuse of the blockchain by one participant could render the system untrustworthy because it entirely relies on the integrity of the collaborators~\cite{lamport2002,sousa12from_byzan_consen_bft_state_machin_replic}. Hence, the proposed approach assumes a form of common interest in which all members trust each other to at least some extent. Using public permissionless platforms in this context might be viable for use cases where data privacy is not of utmost importance. This, however, cannot be said about healthcare-related data. The authors directly encoded information about the patient and her COVID-19 process into the smart contracts. This means that the information would be publicly available to anybody on a public permissionless blockchain, which contradicts the GDPR\footnote{\url{https://gdpr.eu/} (accessed on 2022-11-13)}. Thus, other storage solutions have to be applied if privacy critical data has to be shared with counterparties.


\subsection{Blockchain-based controlled information sharing in inter-organizational workflows~\cite{blockchain_based_information_sharing_in_io_workflows}}

Rondanini et al.\ inspired their work by the trust problems associated with sharing information in inter-organizational scientific choreographies. Especially when APIs of counterparties and other participants have to be consumed, ensuring that the least privilege principle\footnote{A participant is only given exactly those privileges needed to complete a task.} is being followed, might be of utmost importance. To achieve this goal, the authors solely rely on the distributed consensus algorithm of blockchains to guarantee a correct order of execution of business processes (as shown in~\cite{blockchain_for_secure_io_bp}). They split their smart contracts into two layers that are tightly coupled with each other: (1) The \textit{coordination layer} that ensures a correct order of execution of the choreography and (2) the \textit{authorization layer} that handles resource access on a per sub-task basis. To be more specific, the authors tackle temporal authorization management (authorization can be revoked) and the least privilege principle with their novel concept. On choreography initialization and smart contract deployment, each participant has to announce, in the form of transactions with a specific payload format, which resources (for example, APIs) they provide. When participants want to start working on a certain sub-task of the business process, they have to send a transaction containing all required resources to the smart contract that handles this sub-task. The smart contract will then check which resources are applicable and grants access. The resource providers listen to the smart contracts event log and will automatically toggle access to their off-chain resources for this particular participant. The smart contract will revoke resource access once the sub-task executor announces that their work has been completed. Later on, participants can check what kind of resources counterparties used by examining the log of transactions during execution.

The authors' approach to the least privilege principle and the trust problems associated with choreographies allows for automated authorization management and post-execution verifiability of business processes. However, their concept requires choreographies to be relatively inflexible. Participants have to be assigned to sub-tasks they will work on before the business process even starts. Due to the properties of blockchains and transactions, once revealed, resources cannot be revoked either. Drawbacks like these might have severe consequences, especially for long-running business processes where organizations have to comply with changing legal requirements. Revoking access to resources only off-chain might break the entire business process if other participants still require those resources to complete their sub-tasks.


\subsection{A Lean Architecture for Blockchain Based Decentralized Process Execution~\cite{lean_architecture_for_blockchain_based_process_execution}}

In their work, Sturm et al.\ try to leverage on the work of Weber et al.~\cite{untrusted_bp_execution_using_blockchain} by generalizing the smart contracts in use for a ``source-code optimized solution'' that is open for extension if necessary. The smart contract is deployed per instance of a business process and only serves as scaffolding. This scaffolding smart contract holds a list of participants and sub-tasks where each sub-task contains a description of the action that has to be performed, the wallet address of the participant that is allowed to complete the task, and a list of predecessor tasks that must be completed before this task can be tackled. After the scaffolding smart contract deployment, the participants and the tasks are added using functions defined in the contract (i.e.,\ blockchain transactions). To partially conform with \gls{bpmn}, tasks can be defined (1) as simple \textit{TASK}, which only has one predecessor, (2) as \textit{AND}-task, where a list of predecessors has to be completed, or (3) as \textit{OR}-task, where at least one of the predecessor tasks has to be completed before the task itself can be completed. The formal definition of the function $C(t)$ that checks if task $t$ can be completed is depicted in equation~\ref{eq:lean_architecture_complete_condition}.

\begin{equation}
    C(t)=\begin{cases}
        C(P_t) & \text{for simple tasks} \\
        \bigwedge_{t_p \in P_t} C(t_p) & \text{for \textit{AND}-tasks} \\
        \bigvee_{t_p \in P_t} C(t_p) & \text{for \textit{OR}-tasks}
    \end{cases}
    \label{eq:lean_architecture_complete_condition}
\end{equation}

Where $P_t$ is the set of predecessor tasks and $C(t)$ is defined as recursive function. The authors circumnavigated the recursiveness by adding a \textit{completed} flag to each task to prevent the smart contract from performing redundant computation on-chain. The capabilities of error handling in Solidity, the smart contract programming language of Ethereum, specifically allows participants to communicate with the smart contract more directly. Thus, the authors were able to create a cleaner concept compared to~\cite{untrusted_bp_execution_using_blockchain}. Due to the way the scaffolding smart contract works, Sturm et al.\ proposed, that for their concept, a \gls{bpmn} translator would not output smart contract code directly, but would generate a list of blockchain transactions that add participants and tasks that depict the business process itself.

This concept tries to solve the lack of trust in choreographies between counterparties by storing as much information on-chain as possible. The authors even mention, that they do not want to rely on off-chain storage solutions. Thus, even large files and datasets would be attached to tasks on-chain. Not only could the transaction and block size limit cause issues, but participants might also be concerned with privacy regarding their data being published. To deal with associated privacy and security issues, the authors recommend the usage of consortium blockchains\footnote{Blockchains where all miners/validators are predefined and cannot change.}. However, consortium and private blockchains will inevitably weaken the tamper-proofness to some extent because the voting power is concentrated to preselected nodes. Another disadvantage of this approach is that it relies on the inflexibility of its business processes. Due to the immutability of blockchain transactions~\cite{nakamoto2009}, tasks and participants cannot be changed in the proposed concept. Even though the scaffolding smart contract could be extended to allow such behavior, the authors did not establish a sound concept of how participants agree to changes in the process.


\subsection{Interpreted Execution of Business Process Models on Blockchain~\cite{interpreted_bp_on_blockchain_weber}}

Concepts where \gls{bpmn} models are compiled to smart contracts (as proposed in~\cite{untrusted_bp_execution_using_blockchain,bo_collaboration_between_healthcare_providers_covid_19,blockchain_based_information_sharing_in_io_workflows}) do have certain flexibility limitations. To overcome these limitations, LÃ³pez-Pintado et al.\ proposed a concept that utilizes smart contracts to interpret business processes on the blockchain, similar to the previous work of Sturm et al.~\cite{lean_architecture_for_blockchain_based_process_execution}. To reduce the footprint on the blockchain and allow dynamic modification of the business process during run-time, the authors recommend the usage of a space-optimized tree-like data structure that encapsulates the workflow. Even though the interpreter that encodes the \gls{bpmn} semantics only has to be deployed once, each sub-process that participants want to add to the choreography will automatically deploy additional smart contracts (one responsible for the sub-process workflow and another one holding associated model data). Therefore, the proposed concept cannot scale well due to the vast amount of associated contracts deployed~\cite{interpreted_bp_on_blockchain_loukil}. Furthermore, allowing participants to dynamically modify the workflow data structure during run-time might lead to consistency issues (e.g.,\ due to the order in which transactions are accepted by the blockchain~\cite{nakamoto2009,ethereum_yellow_paper}). Even though the concept enables access restrictions for participants, modification might still lead to inconsistent state. The usage of systems, that should establish trust between counterparties, but might still produce inconsistent state on the blockchain, is questionable. Participants might see different state representations of the same business process, which nullifies the usage of blockchain in the first place.


\subsection{Decentralized Collaborative Business Process Execution Using Blockchain~\cite{interpreted_bp_on_blockchain_loukil}}

Building upon the work of~\cite{lean_architecture_for_blockchain_based_process_execution} and~\cite{interpreted_bp_on_blockchain_weber}, Loukil et al.\ aim to further reduce the inflexibility of business process management on the blockchain with their concept. To achieve this goal, three types of smart contracts are deployed in a 3-layer architecture. The central smart contract is called the \textit{interpreter}. It is only deployed once, holds references to the \textit{business process instance} and the \textit{resource instance} smart contracts and implements the facade pattern\footnote{\url{https://en.wikipedia.org/wiki/Facade_pattern} (accessed on 2022-11-13)} to access the business process. When a business process is triggered, the interpreter generates a new business process instance smart contract. Participants then dynamically add the \gls{bpmn}-based configuration to the newly created smart contract through the interpreter using blockchain transactions. Similarly to the business process instance smart contract, the resource instance smart contract that holds and manages the roles of participants, is also generated by the interpreter itself. As mentioned before, these smart contracts are embedded in a 3-layer architecture. The first layer, the \textit{conceptual layer}, is solely responsible for translating \gls{bpmn} models to an intermediary JSON representation to be more blockchain agnostic. The JSON configuration is then fed into the interpreter smart contract that is part of the \textit{data layer}. The data layer statically encodes a basic business process workflow data structure that is the same for all instances. The routing logic and the process workflow are added to the created business process instance smart contracts in the \textit{flow layer}. Business process instance and resource instance smart contracts can only be accessed and configured by the interpreter. This gives the interpreter more leverage over the entire choreography and enables handling whether or not certain participants are allowed to perform certain tasks or if they are allowed to modify the roles or the business process itself.

The evaluation of the concept shows that business process instance deployment typically leads to higher costs regarding gas compared to compiled approaches such as the one proposed by Weber et al.~\cite{untrusted_bp_execution_using_blockchain}. The tight coupling and integration with the blockchain itself also leads to a dependence on the chosen blockchain technology regarding the transaction confirmation time. These two aspects make the concept rather disadvantageous for short-running business processes where many business process instance and resource instance smart contract deployments are required, and state transitions must be performed quickly. Similarly to other proposals, the authors of this concept are also reluctant to tackle the privacy concerns of participants. They advise the usage of consortium blockchains to keep the business process and the associated data private. However, due to the capabilities of the approach to change participants and their roles during run-time, consortium blockchains will inevitably lead to more management overhead since new participants are advised to run their own full node of the blockchain. If participants decline, the usage of blockchain becomes questionable due to security issues like 51\% attacks opening up. Nonetheless, the novel architecture presented by the authors gives opportunity for future work to tackle the issues mentioned above, and its loose coupling allows the integration of other approaches as well.


\subsection{Inter-organizational Business Processes Managed by Blockchain~\cite{inter_organizational_bps_managed_by_blockchain}}
\label{sec:related-work:nakamura}

Due to certain limitations of blockchain technologies like throughput, latency, or size restrictions, Nakamura et al.\ proposed a statechart transformation algorithm for \gls{bpmn} that allowed the authors to bring down the number of dispatching and receiving events by up to 74\% and 65\%. Their approach is structured in three subsequent steps. In the first step, a \gls{bpmn} model is transformed into one statechart for the shared business process on the blockchain and one statechart for each participant. Each statechart represents all states a participant can be in and all corresponding state transitions where state transitions are triggered in the form of events dispatched by any of the participants involved. The authors define a state transition as $e/a_1,\ldots,a_n$ with $e,a \in E$ where $E$ is the set of events that may occur in the business process, $e$ being the receiving event (that starts the state transition) and $a_1,\ldots,a_n$ being the events dispatched after the state transition is completed. Thus, a statechart can be formalized as 5-tuple $\langle S, s_0, F, E, T \rangle$ where S is the set of possible states, $s_0 \in S$ the initial state, $F \subseteq S$ being the set of final states and $T$ is the set of transitions. An event dispatched by the statechart of the shared business process on the blockchain might be used as a state transition starting event for the statechart of one of the participants and thus allows communication between independent statecharts solely relying on a predefined set of events $E$ that all participants share. The proposed algorithm reduces the produced statecharts in the second step. The authors focus on two consecutive state transition where none of them dispatches any events on completion (as depicted in equation~\ref{eq:consecutive_state_transitions_without_dispatching_events}).

\begin{equation}
    s_1 \xrightarrow[]{e_1/\emptyset} s_2 \xrightarrow[]{e_2/\emptyset} s_3
    \label{eq:consecutive_state_transitions_without_dispatching_events}
\end{equation}

Suppose the first state transition from $s_1$ to $s_2$ is removed (including the receiving event $e_1$ that triggers the transition) and the statechart is rewritten to only allow immediate transitions from $s_1$ to $s_3$ using $e_2$ as starting event (as depicted in equation~\ref{eq:consecutive_state_transitions_without_dispatching_events_reduced}). In that case, the observed behavior from outside the statechart will not change because neither less nor more events are being dispatched, and the resulting state is the same.

\begin{equation}
    s_1 \xrightarrow[]{e_2/\emptyset} s_3
    \label{eq:consecutive_state_transitions_without_dispatching_events_reduced}
\end{equation}

This transformation will not only allow the removal of the no longer used state $s_2$ but will also allow the removal of the dispatching event $e_1$ if and only if no other participant or the shared business process itself requires it. One might even consider a generalization of the transformation algorithm for more than two consecutive state transitions without dispatching events as well. The third step proposed by Nakamura et al.\ then includes a transformation of the statecharts to smart contracts and automatically generated web user interfaces that allow interaction with the business process.

Even though this novel approach only considers consecutive state transitions and does not include process forks and joins such as the concept proposed by Prybila et al.~\cite{runtime_verification_for_bp_utilizing_bitcoin,prybila_master_thesis}, the algorithm still holds potential for adaptation in future work due to the vast reduction of dispatching events and the extraction of a dedicated statechart representing the interactions with the blockchain.


\subsection{Data-Driven Process Choreography Execution on the Blockchain: A Focus on Blockchain Data Reusability~\cite{data_driven_choreography_data_reusability_lichtenstein}}

An approach that focuses more on the artifacts produced by a business process and their reusability across instances, was proposed by Lichtenstein et al. The authors' concept focuses on three smart contract types that loosely interact with each other. The first smart contract is the \textit{participants interface}. These interfaces are deployed by each participant involved in the choreography individually and only expose functionality that is relevant for the respective participant to advance the business process instance. The participants' interface further communicates with the \textit{data object store}. This kind of smart contract is deployed once per choreography, holds an instance ID that is increased for each new instance of a business process, and references all required \textit{data object} smart contracts. The data objects are use case and domain-specific smart contracts that depict certain business process artifacts\footnote{Imagine a car rental business process. In such a scenario, typical data objects would be the car, the driver's license, or the order with its corresponding invoice. Each data object has its own lifecycle with its own custom properties.}. These data objects are reused throughout multiple business process instances, which will reduce the number of smart contracts deployed per business process instance dramatically compared to other concepts such as the one proposed by Weber et al.~\cite{untrusted_bp_execution_using_blockchain} or the one proposed by Ilyass El Kassmi and Zahi Jarir~\cite{bo_collaboration_between_healthcare_providers_covid_19}. Data objects are modified through the participants' interface and directly represent the current state of the business process instance. This decoupling of process logic and data objects allows the reuse of data objects in new business process instances and even across choreographies. Therefore, new choreographies with a different process logic and different participant interfaces can import \textit{external} data objects that were produced by other choreographies previously. These external data objects can be used as an additional source of information for newly deployed choreographies.

The dynamic approach proposed is highly beneficial for short-running choreographies where similar business processes are instantiated regularly. Even though the deployment cost is typically higher compared to similar approaches due to the vast amount of data object smart contracts required, the authors could still show a linear decrease in business process instantiation cost. This is due to the circumstance that other approaches deploy all required smart contracts per business process instance, while the approach proposed by Lichtenstein et al., reuses all smart contracts and only has to increase a single variable per instantiation in the data object store. Nonetheless, the approach lacks access rights management and the option to encrypt sensitive data. Thus, further research still has to be conducted considering that data objects are on-chain, and their progression throughout a business process instance is of utmost importance for this approach.


\subsection{Modeling and Enforcing Blockchain-Based Choreographies~\cite{modeling_blockchain_based_choreographies}}

Most of the aforementioned concepts rely on choreography or business process diagrams defined in the \gls{bpmn} 2.0 standard. However, choreography diagrams are regarded to be purely descriptive and thus lack properties required in model-driven engineering to allow process execution. Moreover, the current standard of \gls{bpmn} does not reflect most blockchain capabilities directly. Thus, Ladleif et al.\ proposed a fully backwards-compatible extension to \gls{bpmn} 2.0 choreography diagrams that enable execution by adapting existing and introducing two new elements that allow the representation of data and logic directly on the blockchain. Data is being stored and shared between participants using two different concepts:

\begin{itemize}
    \item \textit{Message exchanges}: Messages that are attached to choreography tasks, and are either sent by the task initiator or the task respondent, are represented by blockchain transactions. Due to the circumstance that all transactions are automatically attached to the immutable event log of the blockchain, all participants can verify the state of the choreography at a later point in time. Messages are converted to byte sequences by the client to allow arbitrary data structures being exchanged.
    \item \textit{Data objects}: The rather artifact-centric approach of this concept introduces so-called \textit{data objects} in the form of variables inside choreography smart contracts. This gives participants more flexibility when sharing information for the progression of the choreography. The append-only data structure that a blockchain is, allows participants to verify if necessary information was shared and if the data objects have been in the correct state to allow a specific state transition, for example.
\end{itemize}

To ensure correctness of the choreography, smart contracts directly embed the control flow logic derived from the choreography diagram. The extension, however, also allows participants to define custom logic in the form of script tasks. These script tasks can access message logs or data objects to check if a task can be completed or if the next task can be started. To enable authorization management and verify if certain participants are allowed to perform state transitions in the choreography, the authors proposed using an additional smart contract called the \textit{participants registry} where each participant has to be registered prior to choreography instantiation.

Even though the proposed concept performs well regarding correctness of the choreography, traceability, and run-time verification, flexibility is still an issue due to the immutability of smart contracts and, thus, not being able to extend or change data objects once deployed and in use. Even though patterns exist for changing data objects (as proposed by Lichtenstein et al.~\cite{data_driven_choreography_data_reusability_lichtenstein}), the integration is still an open problem due to the tight coupling of logic, data objects, and smart contracts. Another issue discussed by the authors is the current limitation of smart contracts not being able to trigger tasks automatically, which is a valuable property, given that the choreography relies on recurring tasks such as monthly settlements. These problems and the privacy and confidentiality issues of storing data on-chain still give opportunities for future work and improvements.



\section{Concept Comparison}
\label{sec:related-work:comparison}
The concepts mentioned above are compared with the concept proposed in this work by some of their most distinctive properties in table~\ref{tab:related_work:concept_comparison}. The compared characteristics are as follows: (1) The \textit{execution} type of the concept on the blockchain. Compiled solutions typically generate smart contracts from some descriptive specification language like \gls{bpmn} or choreography diagrams and automatically deploy them for each instantiation of the \gls{bp}. On the other hand, interpreted solutions generate scaffolding smart contracts, deploy them once, and get populated through transactions that inject the \gls{bp} configuration. (2) The \textit{architecture} property characterizes which kind of blockchain is required to allow optimal execution of \glspl{bp}. (3) The \textit{platform} specifies for which blockchain implementation the concept was proposed and primarily tested on. (4) The \textit{privacy} property categorizes if data privacy is ensured, and if so, lists which mechanism is employed, and (5) often tightly entangled with the previous property, the \textit{on-chain} property indicates what data is stored on the blockchain.

\begin{table}[h]
\centering
\begin{tabular}{|l|c|c|c|c|c|}
    \hline
    \textbf{Concept} & \textbf{Execution} & \textbf{Architect.} & \textbf{Platform} & \textbf{Privacy} & \textbf{On-chain} \\
    \hline
    \cite{untrusted_bp_execution_using_blockchain} & Compiled & Private & Ethereum & Hashed & All \\ % chktex 2
    \cite{runtime_verification_for_bp_utilizing_bitcoin} & Interpreted & Public & Bitcoin & Hashed & Flow \\ % chktex 2
    \cite{bo_collaboration_between_healthcare_providers_covid_19} & Compiled & Private & Hyperledger & None & All \\ % chktex 2
    \cite{blockchain_based_information_sharing_in_io_workflows} & Compiled & Private & Hyperledger & Authorized & Flow \\ % chktex 2
    \cite{lean_architecture_for_blockchain_based_process_execution} & Interpreted & Consortium & Ethereum & None & Flow \\ % chktex 2
    \cite{interpreted_bp_on_blockchain_weber} & Interpreted & Private & Ethereum & None & Flow \\ % chktex 2
    \cite{interpreted_bp_on_blockchain_loukil} & Interpreted & Consortium & Ethereum & None & Flow \\ % chktex 2
    \cite{inter_organizational_bps_managed_by_blockchain} & Compiled & Private & Hyperledger & None & Flow \\ % chktex 2
    \cite{data_driven_choreography_data_reusability_lichtenstein} & Compiled & Private & Ethereum & None & All \\ % chktex 2
    \cite{modeling_blockchain_based_choreographies} & Compiled & Private & Ethereum & None & All \\ % chktex 2
    Proposal & Interpreted & Public & Dynamic & Preserved & Dynamic \\
    \hline
\end{tabular}
\caption{Comparison between different conceptual models and their properties}
\label{tab:related_work:concept_comparison}
\end{table}

Most of the aforementioned related work, as well as concepts not listed above, heavily rely on \gls{bpmn}, choreography diagrams, or extensions to one of both to derive their data models and smart contracts. However, because \gls{bpmn} does not provide any native elements for blockchain integration, some non-functional and functional requirements can not be derived directly. Therefore, some concepts must rely on assumptions that hinder generalization. Nonetheless, recent years have shown a trend from compiled approaches towards interpreted approaches that partially extend existing standards such as \gls{bpmn} to allow easier integration of trusted third parties in the form of blockchains (an example being~\cite{modeling_blockchain_based_choreographies}). Another interesting observation from table~\ref{tab:related_work:concept_comparison} is the rather homogeneous distribution of integrated blockchain platforms. Most concepts either rely on Ethereum or Hyperledger Fabric due to their capabilities of allowing distributed code execution in the form of smart contracts. However, these platforms do come with certain limitations. Two of the most important ones are the transaction limit of Ethereum and the privacy issues of data stored on the blockchain in both cases. A lot of the related work mentioned tries to circumnavigate both issues by either employing private or consortium blockchains. Yet, these kinds of architectures have proven less reliable than their public counterparts. The amount of maintenance and setup required, the fact that blockchains still have not fully arrived in the industry and commerce sector, and the lack of experts in this domain led to a decline in the usage of blockchain solutions. Furthermore, private and consortium blockchains are more prone to be attacked due to the overall lower amount of participants\footnote{In a three-party consortium or private blockchain, it is enough if the participant with the most computing power, or the most at stake, wants to corrupt the entire network. Scenarios like these, again, require trust between participants and thus nullifies most of the advantages of blockchains~\cite{lamport2002}.}~\cite{public_chains_make_private_chains_obsolete}. Over time, concepts that become less trustworthy run into privacy and confidentiality issues. Even though some concepts rely on hashing algorithms to ensure some degree of privacy, most of them do not. This might not be an issue if only the state of the overall choreography is shared between participants on the blockchain; it becomes an issue, however, if the orchestration state or data is visible on-chain. Some data or internal \gls{bp} workflows want to be kept concealed by some participants. Reasons for this can be versatile~\cite{impact_of_trust_on_supply_chains}. Thus, rendering concepts that share such data on-chain unacceptable.

\subsection{Research Question 1}
\label{sec:related-work:comparison:rq1}
To answer the first research question:

\begin{quote}
    \emph{What is the state of the art for \gls{bct}-based state machines for business process engines?}
\end{quote}

Blockchains, and their integration into \glspl{bp}, are hot topics in the research community right now and are gaining ever more attention due to their huge potential~\cite{blockchains_for_bpmn_challenges_and_opportunities}. However, a lack of awareness for privacy and confidentiality issues is widely present in a lot of concepts and proposals. Even though some ideas arise on how this problem can be solved~\cite{blockchain_for_secure_io_bp}, most related work tackles it by employing private and consortium blockchains. This leads to solutions where the entire state, the \gls{bp} itself, and sometimes even highly critical data, is kept on the blockchain only to leverage on its traceability and immutability properties. To do so, the state of the art heavily relies on two primary concepts: (1) either by compiling a specification (mostly in the form of \gls{bpmn}) to smart contracts and deploying them on the blockchain for each instantiation of the \gls{bp} or by (2) deploying scaffolding smart contracts that are later on saturated with the \gls{bp} configuration using blockchain transactions. Especially the latter one has gained more attention in recent years due to the cheaper instantiation cost. Both the compiled and the interpreted concepts create a state machine on the blockchain that is as close to the \gls{bpmn} specification as possible to allow (more or less) direct mappings between both of them. The execution state of the \gls{bp}, as well as related and shared data (especially in artifact-centric solutions), is stored on the blockchain in most of the concepts and advanced with each process step as described in the related work chapter before.

Nonetheless, a gap was identified in the state of the art that requires a traceable and immutable solution leveraging on the properties and advantages of public blockchains, that ensures data (and partially even internal workflow) privacy and confidentiality. The upcoming sections discuss and propose a new concept for a partially off-chain state machine that builds upon related work and well-established software engineering approaches to fill the abovementioned gap in the state of the art.
